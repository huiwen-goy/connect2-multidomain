---
title: "A multi-domain self-report assessment of health in adults with and without hearing loss"
output:
  html_document:
    toc: TRUE
    toc_depth: 2
---

# Preparing the dataset

**Initial steps**
 
1. Downloaded data from Qualtrics (numeric version, in .csv format), on July 2, 2020. Recorded responses n = 553.
2. Deleted second and third header rows (rows 2 and 3).
3. Sort by column "Consent_1_main", and deleted participants who declined to participate; i.e. responded with option 2 or 3 (n = 26). Note: leaves 527 participants.
4. Created Qualtrics ID "key" for matching with Connect IDs, with five columns: ResponseId, RecipientLastName, RecipientFirstName, Consent_1_main, Consent_2_clinic; file named "id_qualtrics.csv".
5. Deleted columns from main Qualtrics dataset: IPAddress, RecipientLastName, RecipientFirstName, RecipientEmail, ExternalReference, LocationLatitude, LocationLongitude, DistributionChannel, UserLanguage
6. Matched Connect IDs to Qualtrics IDs using first and last names.
```{r, eval=FALSE, include=FALSE}

## Match Connect IDs to Qualtrics IDs

# Qualtrics names & id
#qualtrics <- read.csv("id_qualtrics.csv", header=TRUE, na.strings=c(""))

# Check for duplicate names; none
#sum(duplicated(qualtrics[, c('RecipientFirstName', 'RecipientLastName')]))

# Connect names & id
#connect <- read.csv("Name_ID.csv", header=TRUE)

# Merge by first and last names
#ids <- merge(x = qualtrics, y = connect, all.x = TRUE, by.x = c('RecipientFirstName', 'RecipientLastName'), by.y = c('Firstname', 'Lastname'))

# Why are there 3 extra cases (n=530 instead of n=527)? Three names are shared by two people in Connect database, hence each name was duplicated to accommodate two different Connect IDs. Deduced which Connect ID was correct based on respondent's email or year of birth.
#ids[duplicated(ids[, c('RecipientFirstName', 'RecipientLastName')])==TRUE, ]

# Initial result: 147 with no match for Connect ID
#sum(is.na(ids$ID))

# Manual search in Connect list for names
#first <- function(string) {
#  fraglist <- connect[grep(as.character(string), connect$Firstname), ]
#  return(fraglist)
#}

#last <- function(string) {
#  fraglist <- connect[grep(as.character(string), connect$Lastname), ]
#  return(fraglist)
#}

# Check
#id <- read.csv("id_qualtrics_connect.csv", header=TRUE, na.strings = c("", "NA", "<NA>"))
# table(id$Consent_2_clinic, id$Manual, useNA = 'always')

# Final result: Of 527 respondents who consented to participate, 453 matched, 6 matched but declined to share info, 2 matched but did not fill out consent option to share info, 66 unmatched to Connect IDs.

```

7. Matched audiometric and other clinic info to Qualtrics data using Qualtrics IDs.
```{r, eval=FALSE, include=FALSE}

# Qualtrics data
#qdata <- read.csv("Multidomain_2020.07.02_18.16_numeric.csv", header=TRUE, na.strings=c("", "NA", "<NA>"))

# ID key
#id <- read.csv("id_qualtrics_connect.csv", header=TRUE, na.strings = c("", "NA", "<NA>"))
#id <- id[, -c(2, 3, 5)] # leave column 5 in to include Manual

# Clinic data
#cdata <- read.csv("clinic.csv", header=TRUE, na.strings=c("", "NA", "<NA>"))

# Merge Connect IDs to Qualtrics data
#qdata2 <- merge(x = qdata, y = id, all.x = TRUE, by.x = 'ResponseId', by.y = 'QualtricsId')

# Merge clinic data to Qualtrics data
#data <- merge(x = qdata2, y = cdata, all.x = TRUE, by.x = 'ConnectId', by.y = 'ID')

# Renamed columns 15iSSQ with SSQ15i so that column names start with non-numeric character
#colnames(data)[87:101] <- c('SSQ15i_1_1', 'SSQ15i_1_2', 'SSQ15i_1_3', 'SSQ15i_1_4', 'SSQ15i_1_5', 'SSQ15i_2_6', 'SSQ15i_2_7', 'SSQ15i_2_8', 'SSQ15i_2_9', 'SSQ15i_2_10', 'SSQ15i_3_11', 'SSQ15i_3_12', 'SSQ15i_3_13', 'SSQ15i_3_14', 'SSQ15i_3_15')

#write.csv(data, '~/Desktop/Qualtrics_data_2020.07.06.csv')

```

# Evaluating data quality

Of 527 respondents: 453 were matched to Connect IDs; 6 were matched but declined to share info; 2 were matched but did not fill out consent option to share info and are assumed to have declined; 66 were unmatched to Connect IDs (see "cases.pdf").
```{r, eval=FALSE, include=FALSE}

# Read dataset containing Qualtrics data matched to Connect data for those who consented to sharing clinic data

#data <- read.csv("Qualtrics_data_2020.07.06.csv", header=TRUE, na.strings=c("", "NA", "<NA>"))

#d2 <- data[, c('Consent_2_clinic', 'ConnectId', 'ID.clinic', 'Manual')]
# only have Manual variable available if left in 'id' dataset
#table(d2$Manual, d2$Consent_2_clinic, useNA = 'always')

# Make sure those with no clinic consent have clinic data blanked out
#data[data$Consent_2_clinic == 2 & is.na(data$Consent_2_clinic) == FALSE, 274:300]
#data[is.na(data$Consent_2_clinic) == TRUE, 274:300]

```

Of those 453 who consented to share their clinic data and had clinic IDs available, 439 had full audiograms, 3 had a few cells missing from their audiograms, and 11 had completely missing audiograms.
Of the 11 completely missing audiograms, 7 were recovered from the original Connect 1 dataset (before any cleaning). Final result: 446 full audiograms, 3 partial, 4 missing.
```{r, eval=FALSE, include=FALSE}

# Evaluate missing data: Audiograms

#data <- read.csv("Qualtrics_data_2020.07.06.csv", header=TRUE, na.strings=c("", "NA", "<NA>"))
#d1 <- data[data$Consent_2_clinic == 1 & is.na(data$ConnectId) == FALSE, ]
#table(rowSums(is.na(d2[, 289:300])))
#d1[which(rowSums(is.na(d1[, 289:300])) == 12), 1]

#c1 <- read.csv("Connect_Data_20190730_merged_consent_cleaned_new", header=T, na.strings=c("", "NA"))
#d1[which(rowSums(is.na(d1[, 289:300])) == 12), 1] %in% c1$ID
# [1] FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE
# Of the 11 with missing audiograms, 9 are not present in the n=3516 cleaned dataset for Connect 1.
# The 2 that are present in the cleaned dataset have missing audiograms there as well.

#c0 <- read.csv("Connect_Data_20190730.csv", header=T, na.strings=c("", "NA"))
#d1[which(rowSums(is.na(d1[, 289:300])) == 12), 1] %in% c0$ID
# [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE
# Of the 9 that are not present in the cleaned Connect 1 dataset, 7 are present in the original Connect 1 dataset of n=4630, before any cleaning.

# Salvaging audios where available in n=4630 Connect 1 dataset
#audios <- c0[c0$ID %in% d2[which(rowSums(is.na(d2[, 289:300])) == 12), 1], c(1, 115:145)]

#audio <- read.csv("audios.csv", header=TRUE, na.strings=c("", "NA"))

#d1 <- read.csv("Qualtrics_data_2020.07.06.csv", header=TRUE, na.strings=c("", "NA"))

#d2 <- d1
# Put in missing audiograms for 7 people
#d2[d2$ConnectId == 'C2600266' & is.na(d2$ConnectId)==F, 289:300] <- audio[audio$ID == 'C2600266', 3:14]
#d2[d2$ConnectId == 'C2619115' & is.na(d2$ConnectId)==F, 289:300] <- audio[audio$ID == 'C2619115', 3:14]
#d2[d2$ConnectId == 'C2628007' & is.na(d2$ConnectId)==F, 289:300] <- audio[audio$ID == 'C2628007', 3:14]
#d2[d2$ConnectId == 'C2635546' & is.na(d2$ConnectId)==F, 289:300] <- audio[audio$ID == 'C2635546', 3:14]
#d2[d2$ConnectId == 'C2641021' & is.na(d2$ConnectId)==F, 289:300] <- audio[audio$ID == 'C2641021', 3:14]
#d2[d2$ConnectId == 'C2619063' & is.na(d2$ConnectId)==F, 289:300] <- audio[audio$ID == 'C2619063', 3:14]
#d2[d2$ConnectId == 'C2629169' & is.na(d2$ConnectId)==F, 289:300] <- audio[audio$ID == 'C2629169', 3:14]

# Check
#d1[which(rowSums(is.na(d1[, 289:300])) == 12), 1]
#d2[which(rowSums(is.na(d2[, 289:300])) == 12), 1]

#write.csv(d2, '~/Desktop/Qualtrics_data_2020.07.13.csv')

```

# Read current dataset
Qualtrics_data_2020.07.13.csv 
```{r, echo=FALSE}

data <- read.csv("Qualtrics_data_2020.07.13.csv", header=TRUE, na.strings=c("", "NA", "<NA>"))
```

# Data inclusion
 
"Non-conditional items" are items in the questionnaire that make up the shortest possible path through the survey, i.e., skipping all conditional items that only appear given a 'yes' answer earlier. The threshold we decided on for including a participant's data is that they should have less than 10% missing cells in non-conditional items. Using this threshold, 497 (94.3%) participants are included.
 
*Proportion_missing_data* and *Include_over90data* are added as new variables.
```{r, echo = FALSE, include = FALSE}

# Evaluate missing data: Questionnaire items

# Only items comprising the shortest path through survey, excluding consent, metadata, and conditional questions (213 items remaining)
d2 <- data[, c(14:18, 20:53, 58:60, 62, 64, 69:71, 82, 87:121, 124:149, 162:226, 234:272)]

data$Proportion_missing_data <- rowSums(is.na(d2))/213
data$Include_over90data <- ifelse(data$Proportion_missing_data <= 0.1, 1, 0)

sum(data$Include_over90data)
sum(data$Include_over90data)/nrow(data)

rm(d2)

#propNA <- rowSums(is.na(d2))/213
#hist(propNA, breaks = 100, xlim=c(0, 1), col = 'gray', 
  #main = "Items comprising shortest path through survey", 
  #ylab = "Count of participants", xlab = "Proportion NA cells in submitted survey")

# Average percent of missing items per participant = 4.148738%
#mean(propNA)*100

# Cumulative table of present (non-NA) data
#propPresent <- 1 - propNA
#tablePresent <- as.data.frame(table(propPresent))
#tablePresent$Cumfreq <- cumsum(tablePresent$Freq)
#tablePresent$percentPresent <- as.numeric(levels(tablePresent$propPresent))[tablePresent$propPresent] * 100
#tablePresent$CumPercent <- cumsum(tablePresent$Freq)/527 * 100
#tablePresent
# row 25: 93.73814% of participants have at least 90.140845% of data present
```

# Calculating composite scores

**Current list of composite scores:**
 
- Physical health: Total count of co-morbidities
- SSQ15i: Average score, and three average sub-scores
- Social Isolation Measure (SIM): Total score
- Emo-CheQ four items: Total score
- HHIE-S: Total score, and two sub-scores
- Cognitive Self-Report Questionnaire (CSRQ): Total score (no info on scoring)
- Activities-Specific Balance Confidence Scale: Average score
- Satisfaction with Life Scale (SWLS): Average score
- WHOQOL-BREF: Specific scoring procedure in manual
- Loneliness: Scored according to Mick et al. (2018)
- Patient Health Questionnaire (PHQ): Total score
- Social Network Index: Sum; scoring procedure in Mick et al. (2018)
- Social Participation (CCHS / CLSA): Recoding procedure in Mick et al. (2018)
- General Relationship Satisfaction: Average score
- MOS Social Support Survey: Scoring procedure in Mick et al. (2018)
- PTA4 left, right, and better ear

Unless there were specific rules about how to deal with NAs in a scoring procedure, for averages, I generally used na.rm=TRUE, calculating the average without including any NA cells. For totals, I generally used na.rm=FALSE, setting the row total to be NA if there was one or more NA cells (exceptions are the Social Network Index and Social Participant score calculations).
 
```{r, echo=FALSE}

# Physical co-morbidities: total count
data$Comorb_count <- rowSums(data[, c(22:52)] == 1, na.rm=TRUE)

# SSQ 15-item: mean of all items, and three subscales
data$SSQ15i_avg <- rowMeans(data[, c(87:101)], na.rm=TRUE)
data$SSQ15i_avg[which(is.nan(data$SSQ15i_avg))] <- NA #transform NaN to NA
# Qualities subscale
data$SSQ15i_qualities <- rowMeans(data[, c(87:91)], na.rm=TRUE)
data$SSQ15i_qualities[which(is.nan(data$SSQ15i_qualities))] <- NA
# Spatial subscale
data$SSQ15i_spatial <- rowMeans(data[, c(92:96)], na.rm=TRUE)
data$SSQ15i_spatial[which(is.nan(data$SSQ15i_spatial))] <- NA
# Speech subscale
data$SSQ15i_speech <- rowMeans(data[, c(97:101)], na.rm=TRUE)
data$SSQ15i_speech[which(is.nan(data$SSQ15i_speech))] <- NA

# Social Isolation Measure (SIM): sum
data$SIM_total <- rowSums(data[, c(102:106)], na.rm=FALSE)

# Emo-CheQ four items: sum
data$Emocheq4_total <- rowSums(data[, c(107:110)], na.rm=FALSE)

# HHIE-S: total, and two subscales
data$HHIES_total <- rowSums(data[, c(111:120)], na.rm=FALSE)
data$HHIES_emo <- rowSums(data[, c(111, 112, 114, 117, 119)], na.rm=FALSE)
data$HHIES_soc <- rowSums(data[, c(113, 115, 116, 118, 120)], na.rm=FALSE) 

# Cognitive Self-Report Questionnaire (CSRQ): reverse-coded variables so that a high score means better cognition; original response '6' ("does not apply") recoded to NA
cog <- data.frame(case = as.numeric(c(1:527))) # Create new temp dataset

cog$CSRQ_1_recoded <- 6 - data$CSRQ_1 #better
cog$CSRQ_1_recoded[cog$CSRQ_1_recoded == 0] <- NA

cog$CSRQ_2_recoded <- data$CSRQ_2
cog$CSRQ_2_recoded[cog$CSRQ_2_recoded == 6] <- NA

cog$CSRQ_3_recoded <- 6 - data$CSRQ_3 #better
cog$CSRQ_3_recoded[cog$CSRQ_3_recoded == 0] <- NA

cog$CSRQ_4_recoded <- data$CSRQ_4
cog$CSRQ_4_recoded[cog$CSRQ_4_recoded == 6] <- NA

cog$CSRQ_5_recoded <- 6 - data$CSRQ_5 #better
cog$CSRQ_5_recoded[cog$CSRQ_5_recoded == 0] <- NA

cog$CSRQ_6_recoded <- 6 - data$CSRQ_6 #better
cog$CSRQ_6_recoded[cog$CSRQ_6_recoded == 6] <- NA

cog$CSRQ_7_recoded <- data$CSRQ_7
cog$CSRQ_7_recoded[cog$CSRQ_7_recoded == 6] <- NA

cog$CSRQ_8_recoded <- 6 - data$CSRQ_8 #better
cog$CSRQ_8_recoded[cog$CSRQ_8_recoded == 0] <- NA

cog$CSRQ_9_recoded <- data$CSRQ_9
cog$CSRQ_9_recoded[cog$CSRQ_9_recoded == 6] <- NA

cog$CSRQ_10_recoded <- data$CSRQ_10
cog$CSRQ_10_recoded[cog$CSRQ_10_recoded == 6] <- NA

cog$CSRQ_11_recoded <- 6 - data$CSRQ_11 #better
cog$CSRQ_11_recoded[cog$CSRQ_11_recoded == 0] <- NA

cog$CSRQ_12_recoded <- data$CSRQ_12
cog$CSRQ_12_recoded[cog$CSRQ_12_recoded == 6] <- NA

cog$CSRQ_13_recoded <- data$CSRQ_13
cog$CSRQ_13_recoded[cog$CSRQ_13_recoded == 6] <- NA

cog$CSRQ_14_recoded <- 6 - data$CSRQ_14 #better
cog$CSRQ_14_recoded[cog$CSRQ_14_recoded == 0] <- NA

cog$CSRQ_15_recoded <- 6 - data$CSRQ_15 #better
cog$CSRQ_15_recoded[cog$CSRQ_15_recoded == 0] <- NA

cog$CSRQ_16_recoded <- data$CSRQ_16
cog$CSRQ_16_recoded[cog$CSRQ_16_recoded == 6] <- NA

cog$CSRQ_17_recoded <- data$CSRQ_17
cog$CSRQ_17_recoded[cog$CSRQ_17_recoded == 6] <- NA

cog$CSRQ_18_recoded <- 6 - data$CSRQ_18 #better
cog$CSRQ_18_recoded[cog$CSRQ_18_recoded == 0] <- NA

cog$CSRQ_19_recoded <- data$CSRQ_19
cog$CSRQ_19_recoded[cog$CSRQ_19_recoded == 6] <- NA

cog$CSRQ_20_recoded <- 6 - data$CSRQ_20 #better
cog$CSRQ_20_recoded[cog$CSRQ_20_recoded == 0] <- NA

cog$CSRQ_21_recoded <- 6 - data$CSRQ_21 #better
cog$CSRQ_21_recoded[cog$CSRQ_21_recoded == 0] <- NA

cog$CSRQ_22_recoded <- data$CSRQ_22
cog$CSRQ_22_recoded[cog$CSRQ_22_recoded == 6] <- NA

cog$CSRQ_23_recoded <- data$CSRQ_23
cog$CSRQ_23_recoded[cog$CSRQ_23_recoded == 6] <- NA

cog$CSRQ_24_recoded <- data$CSRQ_24
cog$CSRQ_24_recoded[cog$CSRQ_24_recoded == 6] <- NA

cog$CSRQ_25_recoded <- 6 - data$CSRQ_25 #better
cog$CSRQ_25_recoded[cog$CSRQ_25_recoded == 0] <- NA

cog <- cog[, -1]
cog$CSRQ_total <- rowSums(cog[, c(1:25)], na.rm=FALSE)

# CSRQ: sum; transfer final summed variable to official dataset 
data$CSRQ_total <- cog$CSRQ_total

# Activities-Specific Balance Confidence Scale: mean; high is good balance
data$ABC_average <- rowMeans(data[, c(162:177)], na.rm=TRUE)

# Satisfaction with Life Scale (SWLS): mean; low is poor satisfaction
data$SWLS_average <- rowMeans(data[, c(178:182)], na.rm=TRUE)

# WHOQOL-BREF: following instructions in Table 3 of manual 
who <- data[, c(183:208)] # Create new temp dataset

#summary(who) # Check responses of each variable between 1 to 5

who$WHO_3_pai_med_enj_me_1 <- 6 - who$WHO_3_pai_med_enj_me_1 # Reverse-code Q3
who$WHO_3_pai_med_enj_me_2 <- 6 - who$WHO_3_pai_med_enj_me_2 # Reverse-code Q4
who$WHO_8_neg_feelings_1 <- 6 - who$WHO_8_neg_feelings_1 # Reverse-code Q26

# Keep Q1 and Q2 separate
who$WHOQOL_Q1_qol <- data$WHO_1_rate_qol_1 
who$WHOQOL_Q2_health <- data$WHO_2_health_satisf_1

# Compute domain scores; individual domains set to NA if too many NAs.
who$WHOQOL_D1 <- ifelse(rowSums(is.na(who[, c(3, 4, 10, 15, 16, 17, 18)])) <= 1, 
  rowMeans(who[, c(3, 4, 10, 15, 16, 17, 18)], na.rm=TRUE) * 4, NA)
who$WHOQOL_D2 <- ifelse(rowSums(is.na(who[, c(5, 6, 7, 11, 19, 26)])) <= 1, 
  rowMeans(who[, c(5, 6, 7, 11, 19, 26)], na.rm=TRUE) * 4, NA)
who$WHOQOL_D3 <- ifelse(rowSums(is.na(who[, c(20, 21, 22)])) <= 1, 
  rowMeans(who[, c(20, 21, 22)], na.rm=TRUE) * 4, NA)
who$WHOQOL_D4 <- ifelse(rowSums(is.na(who[, c(8,9,12,13,14,23,24,25)])) <= 2, 
  rowMeans(who[, c(8,9,12,13,14,23,24,25)], na.rm=TRUE) * 4, NA)

# At least 21 of 26 questions must be answered, otherwise entire row will be set to NA; this happens to already be the case, but add these steps to make sure
who$WHOQOL_Q1_qol[rowSums(is.na(who[, c(1:26)])) > 5] <- NA
who$WHOQOL_Q2_health[rowSums(is.na(who[, c(1:26)])) > 5] <- NA
who$WHOQOL_D1[rowSums(is.na(who[, c(1:26)])) > 5] <- NA
who$WHOQOL_D2[rowSums(is.na(who[, c(1:26)])) > 5] <- NA
who$WHOQOL_D3[rowSums(is.na(who[, c(1:26)])) > 5] <- NA
who$WHOQOL_D4[rowSums(is.na(who[, c(1:26)])) > 5] <- NA
# checking into which cases have how many NAs
#table(rowSums(is.na(who[, 1:26])))
#which(rowSums(is.na(who[, 1:26])) == 2)
#cbind(c(1:26), t(who[323,1:26])) #D3 should be set to NA; correct

# Check min and max of each domain are within 4 to 20
#summary(who$WHOQOL_D1)
#summary(who$WHOQOL_D2)
#summary(who$WHOQOL_D3)
#summary(who$WHOQOL_D4)

# Copy temp variables to official dataset
data$WHOQOL_Q1_qol <- who$WHOQOL_Q1_qol   
data$WHOQOL_Q2_health <- who$WHOQOL_Q2_health
data$WHOQOL_D1 <- who$WHOQOL_D1
data$WHOQOL_D2 <- who$WHOQOL_D2
data$WHOQOL_D3 <- who$WHOQOL_D3
data$WHOQOL_D4 <- who$WHOQOL_D4

# Patient Health Questionnaire (PHQ): sum
data$PHQ4_total <- rowSums(data[, c(209:212)], na.rm=TRUE)

# Loneliness
# "Participants were classified as lonely if they responded “some of the time” (1 to 2 days), “occasionally” (3 to 4 days), or “all of the time” (5 to 7 days). Those who responded “rarely or never” (<1 day) were considered not lonely." (Mick et al, 2018)

#table(data$CLSA_lonely, useNA = "always") # check categories
data$Lonely <- rep(NA, 527)
data$Lonely[data$CLSA_lonely == 1] <- 0
data$Lonely[data$CLSA_lonely > 1] <- 1
#table(data$CLSA_lonely, data$Lonely, useNA = "always") # check recoding

# Social Network Index

# "Participants scored 1 point if they were married or in a domestic partnership. They also received 1 point (each) if they had interpersonal contact at least every 1 to 2 weeks (during the past year) with children, other close family members, friends, neighbours, work colleagues, schoolmates, fellow volunteers, members of nonreligious community groups, and members of religious groups." (Mick et al, 2018)

data$SNI_total <- rep(NA, 527)
  
sni <- data.frame(case = c(1:527)) # Create new temp dataset

sni$Partner <- ifelse(data$Demo_6_marital == 1, 1, 
                  ifelse(data$Demo_6_marital > 1, 0, NA)) 
#table(sni$Partner, data$Demo_6_marital, useNA="always")

sni$Children <- ifelse(data$Social_SNI_1_1 == 1, 1,
                  ifelse(data$Social_SNI_1_1 == 2, 1, 
                   ifelse(data$Social_SNI_1_1 == 7, 1,  
                    ifelse(data$Social_SNI_1_1 > 2 & data$Social_SNI_1_1 < 7, 0, NA))))
#table(sni$Children, data$Social_SNI_1_1, useNA="always")

sni$Siblings <- ifelse(data$Social_SNI_1_2 == 1, 1,
                  ifelse(data$Social_SNI_1_2 == 2, 1, 
                   ifelse(data$Social_SNI_1_2 == 7, 1,  
                    ifelse(data$Social_SNI_1_2 > 2 & data$Social_SNI_1_2 < 7, 0, NA))))
#table(sni$Siblings, data$Social_SNI_1_2, useNA="always")

sni$Relatives <- ifelse(data$Social_SNI_1_3 == 1, 1,
                  ifelse(data$Social_SNI_1_3 == 2, 1, 
                   ifelse(data$Social_SNI_1_3 == 7, 1,  
                    ifelse(data$Social_SNI_1_3 > 2 & data$Social_SNI_1_3 < 7, 0, NA))))
#table(sni$Relatives, data$Social_SNI_1_3, useNA="always")

sni$Siblings[is.na(sni$Siblings)] <- 0 #collapse Siblings and Relatives
sni$Relatives[is.na(sni$Relatives)] <- 0
sni$CloseRelatives <- ifelse(sni$Siblings == 1 & sni$Relatives == 1, 1,
                      ifelse(sni$Siblings == 1 & sni$Relatives == 0, 1, 
                      ifelse(sni$Siblings == 0 & sni$Relatives == 1, 1,
                      ifelse(sni$Siblings == 0 & sni$Relatives == 0, 0, NA))))
#head(sni[, c('Siblings', 'Relatives', 'CloseRelatives')], 50L)

sni$Friends <- ifelse(data$Social_SNI_1_4 == 1, 1,
                  ifelse(data$Social_SNI_1_4 == 2, 1, 
                    ifelse(data$Social_SNI_1_4 > 2, 0, NA)))
#table(sni$Friends, data$Social_SNI_1_4, useNA="always")

sni$Neighbours <- ifelse(data$Social_SNI_2_1 == 1, 1,
                    ifelse(data$Social_SNI_2_1 == 2, 1, 
                     ifelse(data$Social_SNI_2_1 > 2, 0, NA)))
#table(sni$Neighbours, data$Social_SNI_2_1, useNA="always")

sni$Colleagues <- ifelse(data$Demo_3_employ == 1, 1,
                    ifelse(data$Demo_3_employ == 2, 0, NA))
#table(sni$Colleagues, data$Demo_3_employ, useNA="always")

sni$Schoolmates <- ifelse(data$Social_participate_4 == 1, 1,
                    ifelse(data$Social_participate_4 == 2, 1, 
                     ifelse(data$Social_participate_4 > 2, 0, NA)))
#Educational and cultural activities 
# table(sni$Schoolmates, data$Social_participate_4, useNA="always")

sni$Volunteers <- ifelse(data$Social_participate_7 == 1, 1,
                    ifelse(data$Social_participate_7 == 2, 1, 
                     ifelse(data$Social_participate_7 > 2, 0, NA)))
#Volunteer or charity work
#table(sni$Volunteers, data$Social_participate_7, useNA="always")

sni$Community <- ifelse(data$Social_participate_6 == 1, 1,
                    ifelse(data$Social_participate_6 == 2, 1, 
                     ifelse(data$Social_participate_6 > 2, 0, NA)))
#Neighbourhood, community or professional association 
#table(sni$Community, data$Social_participate_6, useNA="always")

sni$Religious <- ifelse(data$Social_participate_2 == 1, 1,
                    ifelse(data$Social_participate_2 == 2, 1, 
                     ifelse(data$Social_participate_2 > 2, 0, NA)))
#Church or religious activities 
#table(sni$Religious, data$Social_participate_2, useNA="always")

sni$SNI_total <- rowSums(sni[, c("Partner", "Children", "CloseRelatives", "Friends", "Neighbours", "Colleagues", "Schoolmates", "Volunteers", "Community", "Religious")], na.rm=TRUE)
#table(sni$SNI_total, useNA='always')

data$SNI_total <- sni$SNI_total

# Social Participation (CCHS / CLSA)

# "Social participation was measured using 8 items developed for the Canadian Community Health Survey. A composite scale comprising a combination of responses to the social participation items has not been validated, so we classified individuals as having low social participation if they did not participate in any social activities at least once per week. Activities included family or friendship activities outside of the household, church or religious activities, sports or physical activities with others, educational or cultural activities with others, service club activities, community or professional association activities, volunteer work, or any other recreational activity involving other people." (Mick et al, 2018)

# If at least one Social Participation variable has response 1 or 2, coded as '1'; if responses are 3 or greater only, then coded 0; if all are NA's, coded NA
data$Participation <- rep(0, 527)
data$Participation[apply(X = data[, 219:226], MARGIN = 1, FUN = function(r) any(r %in% c(1, 2)))] <- 1
data$Participation[rowSums(is.na(data[, 219:226])) == 8] <- NA

# General Relationship Satisfaction: average
rs <- data.frame(case = c(1:527)) # Create new temp dataset
rs[, 2:8] <- data[, 227:233] # Copy variables into temp dataset
rs$Relation_satisf_2_1 <- 6 - rs$Relation_satisf_2_1 # Reverse-coded 4th item
rs$Relation_satisf_5_1 <- 6 - rs$Relation_satisf_5_1 # Reverse-coded 7th item
rs$RelSatisf_avg <- rowMeans(rs[, c(2:8)], na.rm=TRUE)
rs$RelSatisf_avg[is.nan(rs$RelSatisf_avg) == TRUE] <- NA
data$RelSatisf_avg <- rs$RelSatisf_avg
#table(rowSums(is.na(rs[, 2:8]) == TRUE)) 
# recall this scale is only filled out if in a permanent relationship; about 1 in 3 did not fill this out

# MOS Social Support Survey

# 4 domains of social support (emotional or informational, tangible, affectionate, and positive interactions)
# "For the overall score and the score for each domain, participants were categorized as having low availability of social support if their scores were below the median." (Mick et al, 2018)
# not clear from Mick (2018) or Sherbourne (1991) if the mean or sum should be taken; I chose the mean
# item 13 was not in the original Sherbourne (1991) set; I classed it under POS
# item 20 (pet) was not in the original Sherbourne (1991) set; I left it out

data$SocSuppMOS_overall <- rowMeans(data[, c(234:252)], na.rm=TRUE)
data$SocSuppMOS_overall[is.nan(data$SocSuppMOS_overall) == TRUE] <- NA

data$SocSuppMOS_emoinfo <- rowMeans(data[, c('Social_MOS_2', 'Social_MOS_8', 'Social_MOS_15', 'Social_MOS_18', 'Social_MOS_3', 'Social_MOS_7', 'Social_MOS_12', 'Social_MOS_16')], na.rm=TRUE)
data$SocSuppMOS_emoinfo[is.nan(data$SocSuppMOS_emoinfo) == TRUE] <- NA

data$SocSuppMOS_tangible <- rowMeans(data[, c('Social_MOS_1', 'Social_MOS_4', 'Social_MOS_11', 'Social_MOS_14')], na.rm=TRUE)
data$SocSuppMOS_tangible[is.nan(data$SocSuppMOS_tangible) == TRUE] <- NA

data$SocSuppMOS_affection <- rowMeans(data[, c('Social_MOS_5', 'Social_MOS_9', 'Social_MOS_19')], na.rm=TRUE)
data$SocSuppMOS_affection[is.nan(data$SocSuppMOS_affection) == TRUE] <- NA

data$SocSuppMOS_positive <- rowMeans(data[, c('Social_MOS_6', 'Social_MOS_10', 'Social_MOS_17', 'Social_MOS_13')], na.rm=TRUE)
data$SocSuppMOS_positive[is.nan(data$SocSuppMOS_positive) == TRUE] <- NA

# Calculate PTA4 left, right, and better ear
data$PTA4_left <- rowMeans(data[, c('LE500c', 'LE1000c', 'LE2000c', 'LE4000c')])
data$PTA4_right <- rowMeans(data[, c('RE500c', 'RE1000c', 'RE2000c', 'RE4000c')])
data$PTA4_better_ear <- pmin(data$PTA4_left, data$PTA4_right)

# Under subjective hearing,  "Which aids do you use?" has multiple answers per cell
Subj_hear_4_list_temp <- paste0(data$Subj_hear_4_list, ",") # temp variable; add a comma to the end of each response, to make single digit answers available for matching procedure below
data$Use_HA <- NA
data$Use_HA[grep(pattern = "^1,", x = Subj_hear_4_list_temp)] <- 1
rm(Subj_hear_4_list_temp)
#data.frame(data$Subj_hear_4_list, Subj_hear_4_list_comma, Use_HA)

# Participant group: "NH" is PTA4 better ear ≤ 25; "HL" is > 25; "HA" is defined by an answer of "1" or "1,..." on the item Subj_hear_4_list.
data$Group <- NA
data$Group[data$PTA4_better_ear <= 25.0] <- "NH"
data$Group[data$PTA4_better_ear > 25.0 & is.na(data$Use_HA) == TRUE] <- "HL"
data$Group[data$PTA4_better_ear > 25.0 & data$Use_HA == 1] <- "HA"

```

# Cleaning variables
 
**Year of birth**: *Age* is added as a new variable.
```{r, echo=FALSE, results='hide'}

data$Demo_2_year_cleaned <- data$Demo_2_year # copy columm to new variable
#levels(data$Demo_2_year_cleaned) # only six responses that need cleaning

data$Demo_2_year_cleaned[grep(x = data$Demo_2_year_cleaned, pattern = "03 9 1945")] <- "1945"
data$Demo_2_year_cleaned[grep(x = data$Demo_2_year_cleaned, pattern = "1948./to")] <- "1948"
data$Demo_2_year_cleaned[grep(x = data$Demo_2_year_cleaned, pattern = "around 1959")] <- "1959"
data$Demo_2_year_cleaned[grep(x = data$Demo_2_year_cleaned, pattern = "i939")] <- "1939"
data$Demo_2_year_cleaned[grep(x = data$Demo_2_year_cleaned, pattern = "Nineteenhundredsixtysix")] <- "1966"
data$Demo_2_year_cleaned[grep(x = data$Demo_2_year_cleaned, pattern = "Powell River")] <- NA

data$Demo_2_year_cleaned <- as.numeric(as.character(data$Demo_2_year_cleaned))

#which(nchar(as.character(data$Demo_2_year)) > 4) #228 254 271 447 488
#which(data$Demo_2_year == "i939") #103
#data.frame(data$Demo_2_year, data$Demo_2_year_cleaned) #check cases have been corrected

# new variable: age at study
data$Age <- 2019 - data$Demo_2_year_cleaned

#sum(is.na(data$Age)) # Five NA's
#hist(data$Age, xlim = c(50, 100), breaks = 20, main = "", xlab = "Age at study (years)", col = "grey")

```

# List of all new variables
```{r, echo=FALSE}

str(data[, 301:ncol(data)])

# remove extra datasets created to help with recoding and/or scoring
rm(list = c('cog', 'rs', 'sni', 'who'))
```

# Number of participants in each group
 
The tables show the counts and percentages of participants in the three groups (NH, HL, HA), and participants who will be included (1) or excluded (0) depending on whether they answered at least 90% of non-conditional items. Those in the "NA" group cannot be classified because there is no PTA4 information available for them.
```{r, echo=FALSE}

table(data$Include_over90data, data$Group, useNA = "always")
round(table(data$Include_over90data, data$Group, useNA = "always") / 527 * 100, digits=1)
```
 
# Descriptive plots and tables
 
**From this point onwards, those with unknown Group and or >10% missing data are excluded.**
```{r, echo=FALSE}

# Remove those with unknown Group and >10% missing data; leaves 424
data2 <- data.frame(data[is.na(data$Group) == FALSE & data$Include_over90data == 1, ], stringsAsFactors=FALSE)

```
 
```{r, echo=FALSE, message = FALSE, warning = FALSE}

# Set order of group factor levels (for plotting only)
data2$Group <- factor(data2$Group, levels = c("NH", "HL", "HA", "NA"))

library(ggplot2)

# Age
ggplot(data2, aes(x = Age, fill = Group)) + 
  geom_density(alpha=0.25) + 
  xlab('Age') +
  ylab('Density') + 
  xlim(c(50, 100)) +
  theme(axis.title = element_text(size = 25), axis.text = element_text(size = 15), text = 
      element_text(size = 20))

# PTA4 better ear
ggplot(data2, aes(x = PTA4_better_ear, fill = Group)) + 
  geom_density(alpha=0.25) + 
  xlab('PTA4 better ear (dB HL)') +
  ylab('Density') + 
  xlim(c(0, 60)) +
  theme(axis.title = element_text(size = 25), axis.text = element_text(size = 15), text = 
      element_text(size = 20))

# 15iSSQ average score
ggplot(data2, aes(x = SSQ15i_avg, fill = Group)) + 
  geom_density(alpha=0.25) + 
  xlab('15iSSQ average score') +
  ylab('Density') + 
  xlim(c(0, 10)) +
  theme(axis.title = element_text(size = 25), axis.text = element_text(size = 15), text = 
      element_text(size = 20))

# HHIE-S Social Subscale
ggplot(data2, aes(x = HHIES_soc, fill = Group)) + 
  geom_density(alpha=0.25) + 
  xlab('HHIE-S Social Subscale') +
  ylab('Density') + 
  xlim(c(0, 20)) +
  theme(axis.title = element_text(size = 25), axis.text = element_text(size = 15), text = 
      element_text(size = 20))

# HHIE-S Emotional Subscale
ggplot(data2, aes(x = HHIES_emo, fill = Group)) + 
  geom_density(alpha=0.25) + 
  xlab('HHIE-S Emotional Subscale') +
  ylab('Density') + 
  xlim(c(0, 20)) +
  theme(axis.title = element_text(size = 25), axis.text = element_text(size = 15), text = 
      element_text(size = 20))

# Comorbidities
ggplot(data2, aes(x = Comorb_count, fill = Group)) + 
  geom_density(alpha=0.25) + 
  xlab('Number of comorbidities') +
  ylab('Density') + 
  xlim(c(0, 25)) +
  theme(axis.title = element_text(size = 25), axis.text = element_text(size = 15), text = 
      element_text(size = 20))

# ABC balance scale
ggplot(data2, aes(x = ABC_average, fill = Group)) + 
  geom_density(alpha=0.25) + 
  xlab('Balance confidence') +
  ylab('Density') + 
  xlim(c(0, 100)) +
  theme(axis.title = element_text(size = 25), axis.text = element_text(size = 15), text = 
      element_text(size = 20))

# Cognitive Self Report; note 68 missing rows
ggplot(data2, aes(x = CSRQ_total, fill = Group)) + 
  geom_density(alpha=0.25) + 
  xlab('Cognitive Self-Report total') +
  ylab('Density') + 
  xlim(c(50, 150)) +
  theme(axis.title = element_text(size = 25), axis.text = element_text(size = 15), text = 
      element_text(size = 20))

# Social Isolation Measure
ggplot(data2, aes(x = SIM_total, fill = Group)) + 
  geom_density(alpha=0.25) + 
  xlab('Social Isolation Measure total') +
  ylab('Density') + 
  xlim(c(0, 50)) +
  theme(axis.title = element_text(size = 25), axis.text = element_text(size = 15), text = 
      element_text(size = 20))

# Relationship satisfaction (note: only those in a permanent relationship)
ggplot(data2, aes(x = RelSatisf_avg, fill = Group)) + 
  geom_density(alpha=0.25) + 
  xlab('Relationship satisfaction') +
  ylab('Density') + 
  xlim(c(1, 5)) +
  theme(axis.title = element_text(size = 25), axis.text = element_text(size = 15), text = 
      element_text(size = 20))

# Life satisfaction
ggplot(data2, aes(x = SWLS_average, fill = Group)) + 
  geom_density(alpha=0.25) + 
  xlab('Life satisfaction average') +
  ylab('Density') + 
  xlim(c(0, 10)) +
  theme(axis.title = element_text(size = 25), axis.text = element_text(size = 15), text = 
      element_text(size = 20))

# WHOQOL general quality of life
ggplot(data2, aes(x = WHOQOL_Q1_qol, fill = Group)) + 
  geom_density(alpha=0.25) + 
  xlab('Quality of life (general)') +
  ylab('Density') + 
  xlim(c(1, 5)) +
  theme(axis.title = element_text(size = 25), axis.text = element_text(size = 15), text = 
      element_text(size = 20))

# WHOQOL health-related quality of life
ggplot(data2, aes(x = WHOQOL_Q2_health, fill = Group)) + 
  geom_density(alpha=0.25) + 
  xlab('Quality of life (health)') +
  ylab('Density') + 
  xlim(c(1, 5)) +
  theme(axis.title = element_text(size = 25), axis.text = element_text(size = 15), text = 
      element_text(size = 20))

# WHOQOL domain 1: Physical health
ggplot(data2, aes(x = WHOQOL_D1, fill = Group)) + 
  geom_density(alpha=0.25) + 
  xlab('QoL Domain 1 (Physical)') +
  ylab('Density') + 
  xlim(c(0, 20)) +
  theme(axis.title = element_text(size = 25), axis.text = element_text(size = 15), text = 
      element_text(size = 20))

# WHOQOL domain 2: Psychological health
ggplot(data2, aes(x = WHOQOL_D2, fill = Group)) + 
  geom_density(alpha=0.25) + 
  xlab('QoL Domain 2 (Psychological)') +
  ylab('Density') + 
  xlim(c(0, 20)) +
  theme(axis.title = element_text(size = 25), axis.text = element_text(size = 15), text = 
      element_text(size = 20))

# WHOQOL domain 3: Social relationships
ggplot(data2, aes(x = WHOQOL_D3, fill = Group)) + 
  geom_density(alpha=0.25) + 
  xlab('QoL Domain 3 (Social)') +
  ylab('Density') + 
  xlim(c(0, 20)) +
  theme(axis.title = element_text(size = 25), axis.text = element_text(size = 15), text = 
      element_text(size = 20))

# WHOQOL domain 4: Environment
ggplot(data2, aes(x = WHOQOL_D4, fill = Group)) + 
  geom_density(alpha=0.25) + 
  xlab('QoL Domain 4 (Environment)') +
  ylab('Density') + 
  xlim(c(0, 20)) +
  theme(axis.title = element_text(size = 25), axis.text = element_text(size = 15), text = 
      element_text(size = 20))

# PHQ4
ggplot(data2, aes(x = PHQ4_total, fill = Group)) + 
  geom_density(alpha=0.25) + 
  xlab('PHQ4: Anxiety and Depression') +
  ylab('Density') + 
  xlim(c(0, 20)) +
  theme(axis.title = element_text(size = 25), axis.text = element_text(size = 15), text = 
      element_text(size = 20))
```

**Loneliness**
```{r, echo=FALSE, message = FALSE, warning = FALSE}

# Create separate dataset for Loneliness variable
lonely <- data.frame(Group = data2$Group, Lonely = data2$Lonely)
# Re-label binary variable created previously
lonely$Status <- factor(data2$Lonely, levels=c(0, 1), labels=c("Not lonely", "Lonely"))
#table(lonely$Group, lonely$Status)
round(prop.table(table(lonely$Group, lonely$Status), margin=1), digits=3) * 100

rm(lonely)
```
 
**Social participation**
 
Social participation: Including all participants
```{r, echo=FALSE, message = FALSE, warning = FALSE}

# Create separate dataset for Social Participation
socpart <- data.frame(Group = data2$Group, Participation = data2$Participation)
# Re-label binary variable created previously
socpart$Status <- factor(data2$Participation, levels=c(0, 1), labels=c("Low", "High"))
#table(socpart$Group, socpart$Status)
round(prop.table(table(socpart$Group, socpart$Status), margin=1), digits=3) * 100

rm(socpart)
```
  
Social participation: Only including those who are retired
```{r, echo=FALSE, message = FALSE, warning = FALSE}

# Social Participation
socpart2 <- data.frame(Group = data2[data2$Demo_3_employ == 2, ]$Group, 
  Participation = data2[data2$Demo_3_employ == 2, ]$Participation)
socpart2$Status <- factor(socpart2$Participation, levels=c(0, 1), labels=c("Low", "High"))
#table(socpart2$Group, socpart2$Status)
round(prop.table(table(socpart2$Group, socpart2$Status), margin=1), digits=3) * 100

rm(socpart2)
```
 
**Correlation among subscales of MOS Social Support**
```{r, echo=FALSE, message = FALSE, warning = FALSE}

# MOS Social Support
mos <- data.frame(data[, c('SocSuppMOS_emoinfo', 'SocSuppMOS_tangible', 'SocSuppMOS_affection',  'SocSuppMOS_positive')])
library(psych)
lowerMat(cor(mos, use="complete.obs", method="pearson"))

ggplot(data2, aes(x = SocSuppMOS_emoinfo, fill = Group)) + 
  geom_density(alpha=0.25) + 
  xlab('MOS Social Support (Emo/Info)') +
  ylab('Density') + 
  xlim(c(1, 5)) +
  theme(axis.title = element_text(size = 25), axis.text = element_text(size = 15), text = 
      element_text(size = 20))

ggplot(data2, aes(x = SocSuppMOS_tangible, fill = Group)) + 
  geom_density(alpha=0.25) + 
  xlab('MOS Social Support (Tangible)') +
  ylab('Density') + 
  xlim(c(1, 5)) +
  theme(axis.title = element_text(size = 25), axis.text = element_text(size = 15), text = 
      element_text(size = 20))

ggplot(data2, aes(x = SocSuppMOS_affection, fill = Group)) + 
  geom_density(alpha=0.25) + 
  xlab('MOS Social Support (Affection)') +
  ylab('Density') + 
  xlim(c(1, 5)) +
  theme(axis.title = element_text(size = 25), axis.text = element_text(size = 15), text = 
      element_text(size = 20))

ggplot(data2, aes(x = SocSuppMOS_positive, fill = Group)) + 
  geom_density(alpha=0.25) + 
  xlab('MOS Social Support (Positive)') +
  ylab('Density') + 
  xlim(c(1, 5)) +
  theme(axis.title = element_text(size = 25), axis.text = element_text(size = 15), text = 
      element_text(size = 20))

rm(mos)
```

# Examining co-morbidities
 
## Overall responses for co-morbidity items
```{r, echo=FALSE}

# Rename variables to make them more user-friendly
colnames(data2)[22:52] <- c('cataracts', 'eye', 'allergies', 'asthma', 'lung', 'diabetes', 
  'hypothyroid', 'hyperthyroid', 'cancer', 'heart', 'vascular', 'highbp', 'stroke', 'kidney', 'urinary', 
  'ulcers', 'bowel.disorder', 'bowel.incont', 'osteoarth', 'rheumatoid', 'arthritis', 'osteoporosis', 
  'back', 'memory', 'dementia', 'parkinson', 'ms', 'epilepsy', 'migraine', 'anxiety', 'depression')

# Table of counts
#comorb <- data.frame( 
  #Yes = colSums(data2[, 22:52] == 1, na.rm=TRUE), 
  #No = colSums(data2[, 22:52] == 2, na.rm=TRUE), 
  #DK = colSums(data2[, 22:52] == 3, na.rm=TRUE), 
  #Missing = colSums(is.na(data2[, 22:52])), 
  #Total = rowSums(comorb[, 1:4]) )

# Table of percentages
round(data.frame( 
  Yes = colSums(data2[, 22:52] == 1, na.rm=TRUE) / 424 * 100, 
  No = colSums(data2[, 22:52] == 2, na.rm=TRUE) / 424 * 100, 
  DK = colSums(data2[, 22:52] == 3, na.rm=TRUE) / 424 * 100, 
  Missing = colSums(is.na(data2[, 22:52])) / 424 * 100), digits=1)
```

## Percentage of 'yes' responses for each co-morbidity
```{r, echo=FALSE}

# Subsetting by hearing status
NH <- subset(data2, Group == "NH")
HL <- subset(data2, Group == "HL")
HA <- subset(data2, Group == "HA")

# Table of percentages, of 'yes' responses only
round(data.frame( 
  NH = colSums(NH[, 22:52] == 1, na.rm=TRUE) / nrow(NH) * 100, 
  HL = colSums(HL[, 22:52] == 1, na.rm=TRUE) / nrow(HL) * 100, 
  HA = colSums(HA[, 22:52] == 1, na.rm=TRUE) / nrow(HA) * 100), digits=1)
```
  
## Collapsing conditions into broader categories 
Vision: Cataracts, eye problems  
Cardio: Heart, vascular, high BP, stroke  
Arthritis: Rheumatoid, Arthritis excluding osteoarthritis  
Diabetes: Diabetes  
Mobility: Osteoarthritis, Back problems, Osteoporosis  
Memory: Memory problems, dementia  
Neuro: Parkinson's, MS, epilepsy, migraines  
Psych: Anxiety, depression  
Other: Allergies, asthma, lung, hypothyroid, hyperthyroid, cancer, kidney, urinary, ulcers, bowel.disorder, bowel.incont 
   
## Percentage of 'yes' responses for each type of co-morbidity
```{r, echo=FALSE}

data2$Presence_vision <- ifelse(data2$cataracts == 1 | data2$eye == 1, 1, 0)
data2$Presence_cardio <- ifelse(data2$heart == 1 | data2$vascular == 1 | data2$highbp == 1 | data2$stroke == 1, 1, 0)
data2$Presence_arthritis <- ifelse(data2$rheumatoid == 1 | data2$arthritis == 1, 1, 0)
data2$Presence_diabetes <- ifelse(data2$diabetes == 1, 1, 0)
data2$Presence_mobility <- ifelse(data2$osteoarth == 1 | data2$back == 1 | data2$osteoporosis == 1, 1, 0)
data2$Presence_memory <- ifelse(data2$memory == 1 | data2$dementia == 1, 1, 0)
data2$Presence_neuro <- ifelse(data2$parkinson == 1 | data2$ms == 1 | data2$epilepsy == 1 | data2$migraine == 1, 1, 0)
data2$Presence_psych <- ifelse(data2$anxiety == 1 | data2$depression == 1, 1, 0)
data2$Presence_other <- ifelse(data2$allergies == 1 | data2$asthma == 1 | data2$lung == 1 | data2$hypothyroid == 1 | data2$hyperthyroid == 1 | data2$cancer == 1 | data2$kidney == 1 | data2$urinary == 1 | data2$ulcers == 1 | data2$bowel.disorder == 1 | data2$bowel.incont == 1, 1, 0)

# Subsetting by hearing status
NH <- subset(data2, Group == "NH")
HL <- subset(data2, Group == "HL")
HA <- subset(data2, Group == "HA")

# Mean percentage of each type of comorbidity reported, by group
round(data.frame( 
  NH = colSums(NH[, c('Presence_vision', 'Presence_cardio', 'Presence_arthritis', 'Presence_diabetes', 'Presence_mobility', 'Presence_memory', 'Presence_neuro', 'Presence_psych', 'Presence_other')] == 1, na.rm=TRUE) / nrow(NH) * 100, 
  HL = colSums(HL[, c('Presence_vision', 'Presence_cardio', 'Presence_arthritis', 'Presence_diabetes', 'Presence_mobility', 'Presence_memory', 'Presence_neuro', 'Presence_psych', 'Presence_other')] == 1, na.rm=TRUE) / nrow(HL) * 100, 
  HA = colSums(HA[, c('Presence_vision', 'Presence_cardio', 'Presence_arthritis', 'Presence_diabetes', 'Presence_mobility', 'Presence_memory', 'Presence_neuro', 'Presence_psych', 'Presence_other')] == 1, na.rm=TRUE) / nrow(HA) * 100), digits=1)

```
  
## Association between different types of co-morbidities
  
275 participants have between 2 to 8 types of co-morbidities. In the matrix below, each point is a pair of associated types of co-morbidities within a person. The same person may appear multiple times throughout the matrix, depending on how many pairs of associated types of conditions they have. 96 participants have only 1 type of co-morbidity and 50 participants have none, so these groups are not depicted.
  
![](comorb.jpg)
```{r, eval=FALSE, include=FALSE}

# Getting ready to plot pairs of conditions
data2$Plot_vision <- ifelse(data2$Presence_vision == 1, 1, NA)
data2$Plot_cardio <- ifelse(data2$Presence_cardio == 1, 2, NA)
data2$Plot_arthritis <- ifelse(data2$Presence_arthritis == 1, 3, NA)
data2$Plot_diabetes <- ifelse(data2$Presence_diabetes == 1, 4, NA)
data2$Plot_mobility <- ifelse(data2$Presence_mobility == 1, 5, NA)
data2$Plot_memory <- ifelse(data2$Presence_memory == 1, 6, NA)
data2$Plot_neuro <- ifelse(data2$Presence_neuro == 1, 7, NA)
data2$Plot_psych <- ifelse(data2$Presence_psych == 1, 8, NA)
data2$Plot_other <- ifelse(data2$Presence_other == 1, 9, NA)

# Create empty dataset to receive all pairs of co-morbidities
dfco <- data.frame(id = as.character(), 
                   group = as.character(),
                   comorb.1 = as.numeric(), 
                   comorb.2 = as.numeric(), stringsAsFactors = FALSE)

# If a person has > 1 comorbidity, all possible pairs of their conditions will be noted
for (i in 1:424) {
  if (is.na(rowSums(data2[i, c("Presence_vision", "Presence_cardio", "Presence_arthritis", "Presence_diabetes", "Presence_mobility", "Presence_memory","Presence_neuro", "Presence_psych", "Presence_other")])) == FALSE &
    rowSums(data2[i, c("Presence_vision", "Presence_cardio", "Presence_arthritis", "Presence_diabetes", "Presence_mobility", "Presence_memory","Presence_neuro", "Presence_psych", "Presence_other")]) > 1) {
    
    conditions <- data2[i, c("Plot_vision", "Plot_cardio", "Plot_arthritis", "Plot_diabetes", "Plot_mobility", "Plot_memory", "Plot_neuro", "Plot_psych", "Plot_other")][is.na(data2[i, c("Plot_vision", "Plot_cardio", "Plot_arthritis", "Plot_diabetes", "Plot_mobility", "Plot_memory", "Plot_neuro", "Plot_psych", "Plot_other")]) == F]
    output <- t(combn(conditions, m = 2))
    
    current.rows <- nrow(dfco)
    
    dfco[(current.rows + 1) : (current.rows + nrow(output)), 1] <- rep(data2$ConnectId[i], nrow(output))
    dfco[(current.rows + 1) : (current.rows + nrow(output)), 2] <- rep(data2$Group[i], nrow(output))
    dfco[(current.rows + 1) : (current.rows + nrow(output)), 3:4] <- output
  }
}

rm(list = c('output', 'conditions', 'current.rows', 'i'))

dfco$group <- factor(dfco$group, levels = c("NH", "HL", "HA")) 

ggplot(dfco, aes(x = jitter(comorb.2), y = jitter(comorb.1))) + 
  geom_point(size = 2, colour = "black", alpha = 0.3) +
  facet_grid(~ group) + 
  coord_cartesian(xlim=c(1, 9), ylim=c(1, 9)) +
  xlab('Co-morbidity A') +
  ylab('Co-morbidity B') + 
  scale_x_continuous(breaks = seq(1, 9, by = 1), labels=c("Vi", "Ca", "Ar", "Di", "Mo", "Me", "Ne", "Ps", "O")) + 
  scale_y_continuous(breaks = seq(1, 9, by = 1), labels=c("Vision", "Cardio", "Arth", "Diab", "Mobil", "Mem", "Neuro", "Psych", "Other")) + 
  theme_bw() +
  theme(axis.title = element_text(size = 25, face="bold"), 
    axis.text = element_text(colour = "black", size = 16, face="bold"), 
    text = element_text(size = 20))


```

Note: There are 1179 pairs of types of conditions in the plot.
```{r, eval=FALSE, include=FALSE}

# Check that final number of pairs of conditions is correct
data2$Comorb_types <- rowSums(data2[c("Presence_vision", "Presence_cardio", "Presence_arthritis", "Presence_diabetes", "Presence_mobility", "Presence_memory","Presence_neuro", "Presence_psych", "Presence_other")])

counts <- data.frame(table(data2$Comorb_types, useNA='always'))
names(counts) <- c('number_comorb', 'number_people')
counts$number_comorb <- as.numeric(as.character(counts$number_comorb))

counts$combinations <- ifelse(counts$number_comorb > 1, 
                              choose(counts$number_comorb, 2) * counts$number_people, 
                              0)

sum(counts$number_people, na.rm=TRUE) #424 subjects is correct
sum(counts$combinations, na.rm=TRUE) #expect 1179 pairs of conditions
```
 
## Predicting hearing loss from comorbidities 
Looking at the whole sample of participants, having greater PTA is associated with being older (p < 0.0001), being male (p = 0.003), to a slight extent having a cardiovascular disorder (p = 0.06), but not with having arthritis or diabetes.
```{r, echo=FALSE}

# recode "gender" to 0 and 1
data2$Sex <- c(0)
data2$Sex[data2$Demo_1_gender == 2] <- 1

# no missing data for variables of interest; n = 422
data3 <- subset(data2, 
                is.na(data2$PTA4_better_ear) == FALSE & 
                is.na(data2$Sex) == FALSE & 
                is.na(data2$Age) == FALSE &
                is.na(data2$Presence_arthritis) == FALSE &
                is.na(data2$Presence_cardio) == FALSE &
                is.na(data2$Presence_diabetes) == FALSE)

m1 <- lm(PTA4_better_ear ~ Age + Sex + Presence_arthritis + Presence_cardio + Presence_diabetes, 
          data = data3)
summary(m1)
```
  
Looking only at people with PTA > 25, age still has a relationship with PTA (p = 0.0479), and diabetes has a slight relationship (p = 0.0947).
```{r, echo=FALSE}

# exclude those with PTA ≤ 25; n = 155
data4 <- subset(data2, 
                is.na(data2$PTA4_better_ear) == FALSE & 
                data2$PTA4_better_ear > 25 & 
                is.na(data2$Sex) == FALSE & 
                is.na(data2$Age) == FALSE &
                is.na(data2$Presence_arthritis) == FALSE &
                is.na(data2$Presence_cardio) == FALSE &
                is.na(data2$Presence_diabetes) == FALSE)

m2 <- lm(PTA4_better_ear ~ Age + Sex + Presence_arthritis + Presence_cardio + Presence_diabetes, 
          data = data4)
summary(m2)
```
 
# Examining quality of life
Example analysis: In people with hearing loss (PTA > 25), general QoL is strongly associated with Health QoL and overall social support, but doesn't seem to be related to whether they use hearing aids, or their level of social participation.
```{r, echo=FALSE}

data2$UseHA <- c(0)
data2$UseHA[data2$Use_HA == 1] <- 1

data5 <- subset(data2, 
                is.na(data2$PTA4_better_ear) == FALSE & 
                data2$PTA4_better_ear > 25 & 
                is.na(data2$WHOQOL_Q1_qol) == FALSE & 
                is.na(data2$WHOQOL_Q2_health) == FALSE & 
                is.na(data2$UseHA) == FALSE &  
                is.na(data2$Participation) == FALSE &
                is.na(data2$SocSuppMOS_overall) == FALSE)

m3 <- lm(WHOQOL_Q1_qol ~ WHOQOL_Q2_health + UseHA + Participation + SocSuppMOS_overall, 
          data = data5)
summary(m3)

# Cleaning up
rm(list = c('data3', 'data4', 'data5'))

```
  
# Examining loneliness
  
Using only n=424 cases in Connect 2, where participants have a known Hearing Group and ≥90% data, Connect 1 data was matched to Connect 2 data using clinic IDs.
```{r, eval = FALSE, include = FALSE}

### Merging Connect 1 and Connect 2 data

# Read Connect 2 dataset
data <- read.csv("Qualtrics_data_2020.07.13.csv", header=TRUE, na.strings=c("", "NA"))

# Run code up until line 577 to calculate new variables

# Exclude those with unknown Group and too much missing data (n=424 remaining)
c2 <- data[is.na(data$Group) == FALSE & data$Include_over90data == 1, ]

# Duplicate column of IDs to use for merging
c2$ID <- c2$ConnectId

# Read Connect 1 dataset (n=3509)
# Duplicate ID column already exists
c1 <- read.csv("Connect_Data_20191025.csv", header=TRUE, na.strings=c("", "NA"))

# Pull Connect 1 data into Connect 2
c3 <- merge(x = c2, y = c1, all.x = TRUE, by.x = 'ID', by.y = 'ID')

# Delete duplicated columns labelled with a .x suffix
c4 <- c3[, -c(275:301, 333:335)]
write.csv(c4, "~/Desktop/Connect1_Connect2_merged_2020.09.08.csv")

# Note: easier to delete the .y suffixes manually in batch; columns370 to 402; fix the Age.Years header
```
  
Connect1_Connect2_merged_2020.09.08
```{r, echo=FALSE}

cdata <- read.csv("Connect1_Connect2_merged_2020.09.08.csv", header=TRUE, na.strings=c("", "NA"))
```

## Current loneliness status by hearing status
  
The proportion of those who were lonely (at the current time) did not differ by hearing status.
```{r, echo = FALSE}  

cdata$Group <- factor(cdata$Group, levels = c("NH", "HL", "HA"))
cdata$Lonely[cdata$Lonely == 1] <- "Yes"
cdata$Lonely[cdata$Lonely == 0] <- "No"
addmargins(table(cdata$Lonely, cdata$Group))
t <- table(cdata$Lonely, cdata$Group)
chisq.test(t, correct=FALSE)
rm(t)

# manual calculation; chi-sq = 4.799151, df = (3-1)*(2-1) = 2; critical = 5.99
#((219 - 213.6415)^2/213.6415 + 
  #(49 - 54.35849)^2/54.35849 + 
  #(69 - 76.5283)^2/76.5283 + 
  #(27 - 19.4717)^2/19.4717 + 
  #(50 - 47.83019)^2/47.83019 + 
  #(10 - 12.16981)^2/12.16981 )
```
 
## Change in loneliness from Time 1 to Time 2
  
The same question on loneliness was asked in Connect 1 as in Connect 2: "In the past week, how often did you feel lonely? All of the time (4), Occasionally (3), Some of the time (2), Rarely or never (1)." All 424 cases in Connect 2 have loneliness data available, while 22 of these people are missing loneliness data from Connect 1. Only the 402 people with both Connect 1 and Connect 2 loneliness data available are analyzed.

|Group|Same at T2|Less lonely at T2|More lonely at T2|
|-----|-----|-----|-----|
|NH|80.9%|6.2%|12.8%|
|HL|73.3%|10.0%|16.7%|
|HA|83.6%|5.5%|10.9%|
  
```{r, echo=FALSE, results='hide', fig.show='hide'}

# exclude those with missing data for Time 1 or Time 2
c2 <- cdata[is.na(cdata$Q55_Corrected) == FALSE & 
            is.na(cdata$CLSA_lonely) == FALSE, ]

# arrange factor levels for hearing group variable
c2$Group <- factor(c2$Group, levels = c("NH", "HL", "HA"))

# new variable, T2 - T1 loneliness
c2$Loneliness_change <- c2$CLSA_lonely - c2$Q55_Corrected

# Calculate how stayed the same, got better, or got worse, per group
d <- data.frame(Connect1 = c2$Q55_Corrected, 
                 Connect2 = c2$CLSA_lonely, 
                 Group = c2$Group)
t <- table(d[, 1], d[, 2], d[, 3], dnn = c("Connect 1", "Connect 2", "Group"))
addmargins(t)

# NH (same, better, worse)
(196+8+4+0)/257
(12+1+1+2)/257
(20+6+4+1+2)/257
# HL
(60+6+0+0)/90
(5+1+2+1)/90
(7+2+3+2+1)/90
# HA
(44+1+1+0)/55
(1+2)/55
(5+1)/55
#table(d$Group)

library(ggplot2)

# scatterplot showing Time 1 vs Time 2, by group
# export 6 x 16 inches
ggplot(c2, aes(x = jitter(Q55_Corrected, factor = 0.75), y = jitter(CLSA_lonely, factor = 0.75), group = Group)) + 
  geom_abline(intercept = 0, slope = 1, col = "gray50") + 
  geom_point(size = 2, alpha=0.5) +
  xlab('Time 1 Loneliness') +
  ylab('Time 2 Loneliness') + 
  coord_cartesian(xlim=c(0.5, 4.5), ylim=c(0.5, 4.5)) + 
  facet_grid( ~ Group) + 
  theme_bw() +   
  theme(axis.title = element_text(size = 25), 
    axis.text = element_text(colour = "black", size = 20), 
    text = element_text(size = 20))
```
 
![](loneliness.jpg)
 
```{r, echo=FALSE, message=FALSE, warning = FALSE}

# scatterplots showing change in loneliness (T2 - T1), by group, against other variables
ggplot(c2, aes(x = HHIES_total, y = jitter(Loneliness_change), group = Group)) + 
  geom_point(size = 2) +
  xlab('HHIES total') +
  ylab('T2 - T1 loneliness') + 
  facet_grid( ~ Group) + 
  theme_bw() +   
  theme(axis.title = element_text(size = 25), 
    axis.text = element_text(colour = "black", size = 20), 
    text = element_text(size = 20))

ggplot(c2, aes(x = SNI_total, y = jitter(Loneliness_change), group = Group)) + 
  geom_point(size = 2) +
  xlab('Social Network Index') +
  ylab('T2 - T1 loneliness') + 
  facet_grid( ~ Group) + 
  theme_bw() +   
  theme(axis.title = element_text(size = 25), 
    axis.text = element_text(colour = "black", size = 20), 
    text = element_text(size = 20))

ggplot(c2, aes(x = SocSuppMOS_overall, y = jitter(Loneliness_change), group = Group)) + 
  geom_point(size = 2) +
  xlab('Social support MOS') +
  ylab('T2 - T1 loneliness') + 
  facet_grid( ~ Group) + 
  theme_bw() +   
  theme(axis.title = element_text(size = 25), 
    axis.text = element_text(colour = "black", size = 20), 
    text = element_text(size = 20))
```
  

  